<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ios on Samuel Debruyn</title>
    <link>https://chipsncookies.com/tags/ios/</link>
    <description>Recent content in Ios on Samuel Debruyn</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>s@muel.be (Samuel Debruyn)</managingEditor>
    <webMaster>s@muel.be (Samuel Debruyn)</webMaster>
    <lastBuildDate>Mon, 29 Aug 2016 11:10:40 +0200</lastBuildDate>
    <atom:link href="https://chipsncookies.com/tags/ios/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Creating a Xamarin.iOS binding project for dummies</title>
      <link>https://chipsncookies.com/2016/creating-a-xamarin.ios-binding-project-for-dummies/</link>
      <pubDate>Mon, 29 Aug 2016 11:10:40 +0200</pubDate>
      <author>s@muel.be (Samuel Debruyn)</author>
      <guid>https://chipsncookies.com/2016/creating-a-xamarin.ios-binding-project-for-dummies/</guid>
      <description>

&lt;h2 id=&#34;what-you-need&#34;&gt;What you need&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Experience with Xamarin.iOS&lt;/li&gt;
&lt;li&gt;Xamarin Studio for Mac&lt;/li&gt;
&lt;li&gt;An empty binding project (just create a new project in Xamarin Studio)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-very-short-intro-to-objective-c-for-c-developers&#34;&gt;A very short intro to Objective-C for C# developers&lt;/h2&gt;

&lt;p&gt;Oh god, Obj-C, the most incomprehensible programming language in the app dev world. You simply can&amp;rsquo;t create an iOS binding project without some very basic knowledge of Obj-C. So here goes, an intro to Obj-C for C# developers.&lt;/p&gt;

&lt;p&gt;When you&amp;rsquo;re developing a bindings library, you&amp;rsquo;ll get the iOS project in one of the following forms:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a .a file (static library) - basically like a .DLL&lt;/li&gt;
&lt;li&gt;a .framework file (Cocoa Touch framework) - basically like a .DLL with some resources&lt;/li&gt;
&lt;li&gt;a CocoaPod - just like NuGet&lt;/li&gt;
&lt;li&gt;source code with project file (containing a .xcodeproj file) - like source code including .csproj and .sln files&lt;/li&gt;
&lt;li&gt;source code without project file - just like a bunch of .cs files&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Obj-C projects have .h files and .m files. The headers (.h files) describe something like a class. You could think of them like interfaces. The models (.m files) are the implementations. Each .h file has one .m file. Except for those files, every project usually has an &lt;em&gt;info.plist&lt;/em&gt; file describing project settings (names, supported architectures&amp;hellip;) and a &lt;em&gt;MyProject.xcodeproj&lt;/em&gt; file (this is actually a directory containing multiple configuration files) describing the build settings etc.&lt;/p&gt;

&lt;p&gt;Now, there are a few concepts in the programming language itself which you should be familiar with:&lt;/p&gt;

&lt;h3 id=&#34;protocols&#34;&gt;Protocols&lt;/h3&gt;

&lt;p&gt;Protocols are like interfaces or abstract classes. The main difference between C# interfaces and protocols are the optional methods. The protocol defines optional methods that the models may or may not implement. Each class in Obj-C can implement multiple protocols just like a C# class can implement multiple interfaces. Protocols are usually translated in C# as abstract classes. Note that when you&amp;rsquo;re overriding from a protocol, the base method could have no implementation if the original Obj-C method was optional. This means that you generally should avoid calling the base methods. When in doubt, consult &lt;a href=&#34;https://developer.apple.com/reference/&#34;&gt;the Apple developer documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;umbrella-headers&#34;&gt;Umbrella headers&lt;/h3&gt;

&lt;p&gt;Each iOS framework or library has one header that is the umbrella header for that project. It contains references to all the other headers in that project and defines the base functionality for that library. The umbrella header should have the same name as the project itself. This header is essential for our binding project. Sometimes, you&amp;rsquo;ll have to modify this header to include references to other relevant headers in the project for the bindings to work properly. When that&amp;rsquo;s the case, you just have to add &lt;code&gt;#import &amp;quot;AnotherHeader.h&amp;quot;&lt;/code&gt; statements at the top of the file, just like the &lt;code&gt;using&lt;/code&gt; statement in C#.&lt;/p&gt;

&lt;p&gt;It may be useful to browse through &lt;a href=&#34;https://developer.xamarin.com/guides/ios/application_fundamentals/delegates,_protocols,_and_events/&#34;&gt;this documentation page&lt;/a&gt; at Xamarin.com.&lt;/p&gt;

&lt;h3 id=&#34;static-libraries-and-frameworks&#34;&gt;Static libraries and frameworks&lt;/h3&gt;

&lt;p&gt;When you want to distribute something in the .NET world, you usually just create a class library and distribute its source code or the compiled version (DLL). There are two types of libraries in the iOS world.&lt;/p&gt;

&lt;p&gt;Cocoa Touch Static Libraries are just like the class libraries you know in .NET. The other kind, frameworks, are about the same but they also contain the headers (most of the time just the umbrella header) and media resources (like a NuGet package).&lt;/p&gt;

&lt;h2 id=&#34;getting-started-with-your-binding-project&#34;&gt;Getting started with your binding project&lt;/h2&gt;

&lt;p&gt;To create a binding project for iOS, you&amp;rsquo;ll need the Objective Sharpie tool. The latest version is available at &lt;a href=&#34;https://developer.xamarin.com/guides/cross-platform/macios/binding/objective-sharpie/getting-started/&#34;&gt;Xamarin&amp;rsquo;s website&lt;/a&gt; and if you already have the tool installed, you can use the &lt;code&gt;sharpie update&lt;/code&gt; command to make sure you have the latest version.&lt;/p&gt;

&lt;p&gt;A binding project consist of three parts:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A native reference (either an .a file or a .framework file)&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;StructsAndEnums.cs&lt;/em&gt; file containing all the used enums&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;ApiDefinitions.cs&lt;/em&gt; file containing all the definitions of the classes used in the iOS framework/library&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The API definitions are a list of interfaces with methods decorated with attributes. The attributes tell Xamarin how it should generate the C# API that is bound to the native code. There should be at least one interface with the name of the project itself (or the name of the umbrella header).&lt;/p&gt;

&lt;p&gt;The following sections describe how to generate both files using Objective Sharpie from easiest to most difficult approach. In most cases, you can try multiple approaches. So if one of them doesn&amp;rsquo;t properly generate the API definitions for you, just move on and try another one. You&amp;rsquo;d be surprised how much of a difference they can make, even if the framework and the CocoaPod contain the same files. I strongly recommmend to read through every approach.&lt;/p&gt;

&lt;h3 id=&#34;when-the-project-is-available-as-cocoapod-https-cocoapods-org-recommended-approach&#34;&gt;When the project is available as &lt;a href=&#34;https://cocoapods.org&#34;&gt;CocoaPod&lt;/a&gt; (recommended approach)&lt;/h3&gt;

&lt;p&gt;.NET developers are usually familiar with NuGet packages. They always contain a bunch of .dll files and define dependencies and compatible project types. CocoaPods consist of either compiled code, either source code. To generate the API definitions from a CocoaPod, use the following commands in an empty directory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sharpie pod init ios MyCocoaPod
sharpie pod bind -n MyNamespace
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The CocoaPod is downloaded to the &lt;em&gt;Pods&lt;/em&gt; directory. When you browse through its files, you&amp;rsquo;ll quickly notice if it contains just the source code or also a binary file (without extension), a framework or a static library (.a file).&lt;/p&gt;

&lt;h3 id=&#34;when-the-project-is-available-as-a-framework-file&#34;&gt;When the project is available as a .framework file&lt;/h3&gt;

&lt;p&gt;When your project is supplied as a framework, simply open the framework and verify if it has a compiled binary file inside. If it has one, read the part above about the binary file below. Otherwise, use the source code to create the binary yourself as documented below.&lt;/p&gt;

&lt;p&gt;Alternatively, the following command may also do the job, this doesn&amp;rsquo;t always work though.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sharpie bind -o OutputDirectory -sdk iphoneos9.3 -n MyNamespace MyFramework.framework
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;inspecting-the-binary-file-without-extension-or-a-file-and-generating-api-definitions&#34;&gt;Inspecting the binary file (without extension or .a file) and generating api definitions&lt;/h2&gt;

&lt;p&gt;What you have to verify is the architecture. The iOS simulator has the &lt;code&gt;i386 x86_64&lt;/code&gt; architectures and iPhones and iPads have the &lt;code&gt;armv7 arm64&lt;/code&gt; and possibly &lt;code&gt;armv7s&lt;/code&gt; (only useful on iPhone 5/5c) architectures. You can use the &lt;code&gt;lipo&lt;/code&gt; command to verify the architectures of a binary like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lipo -info MyFramework.framework/MyFramework
lipo -info Pods/MySDK/MySDK.framework/MySDK
lipo -info JustABinary.a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to debug your app in the iOS simulator, you &lt;em&gt;need&lt;/em&gt;  the simulator architectures. But make sure to remove these architectures &lt;strong&gt;when you submit your app to the App Store&lt;/strong&gt; as Apple could deny your app if it includes simulator bytecode. The command to remove these architectures is the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lipo -remove i386 x86_64 -output Path/To/Binary/File Path/To/Binary/File
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you can&amp;rsquo;t access the binary file after you&amp;rsquo;ve created the bindings. This means that you possibly could have to create two versions of the binding project. One with the simulator architectures and one without them. The only difference would be the referenced file in the native references. This can easily be fully automated with MSBuild targets or in your continuous integration process.&lt;/p&gt;

&lt;p&gt;If the binary file doesn&amp;rsquo;t include the architectures you require, try to build it yourself as documented below.&lt;/p&gt;

&lt;p&gt;Now, if you have a binary, regardless of its architectures, you can use it to generate the necessary API definitions. This is what the Xamarin tooling uses to build the bindings itself.&lt;/p&gt;

&lt;h2 id=&#34;building-the-binary-file-yourself&#34;&gt;Building the binary file yourself&lt;/h2&gt;

&lt;p&gt;If you don&amp;rsquo;t have a binary file or if your binary file doesn&amp;rsquo;t support all the architectures you need, you end up building one yourself. This is the hardest part of the binding process but it&amp;rsquo;s well documented on &lt;a href=&#34;https://developer.xamarin.com/guides/ios/advanced_topics/binding_objective-c/walkthrough/#Creating_A_Static_Library&#34;&gt;Xamarin&amp;rsquo;s website&lt;/a&gt;. The Xamarin guide describes how to create a static library, but I found it easier to create a framework instead. I used Xcode 7 for this part, but the minimum is Xcode 6.&lt;/p&gt;

&lt;p&gt;If the source code already contains an Xcode project, you&amp;rsquo;re golden. Just open the Xcode project and try to build it. If not, continue&amp;hellip;&lt;/p&gt;

&lt;p&gt;Create a new Xcode project and choose &lt;em&gt;iOS &amp;gt; Framework &amp;amp; Library &amp;gt; Cocoa Touch Framework&lt;/em&gt;. Now you basically have to put all the files from the source code in this project. You can&amp;rsquo;t replace the header that Xcode created by default, so just copy paste the code from the header in the sources into the one that Xcode created. Try to build the project. Sometimes the linking goes wrong and you have to fix the links between the .h and the .m files yourself.&lt;/p&gt;

&lt;h3 id=&#34;creating-the-binary-for-multiple-architectures&#34;&gt;Creating the binary for multiple architectures&lt;/h3&gt;

&lt;p&gt;As mentioned before, you&amp;rsquo;ll probably need a binary that contains the following architectures: &lt;code&gt;i386 x86_64 armv7 arvmv64&lt;/code&gt; and you can use the &lt;code&gt;lipo -info mybinary&lt;/code&gt; command to inspect the supported architectures. Your binary probably won&amp;rsquo;t contain all of them, so you can use the commands below to combine build and combine multiple binaries:&lt;/p&gt;

&lt;h4 id=&#34;build-for-arm-devices&#34;&gt;Build for ARM devices&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;/Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild ONLY_ACTIVE_ARCH=NO -project XcodeProject.xproj -target NameOfTheProject -sdk iphoneos -configuration Release clean build
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;build-for-simulator&#34;&gt;Build for simulator&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;/Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild ONLY_ACTIVE_ARCH=NO -project XcodeProject.xproj -target NameOfTheProject -sdk iphonesimulator -configuration Release clean build
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;combine-both-binaries-into-one&#34;&gt;Combine both binaries into one&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;lipo -create -output PathToCombinedFile PathToARMBinary PathToSimulatorBinary
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;makefile-which-does-everything-for-you&#34;&gt;Makefile which does everything for you&lt;/h4&gt;

&lt;p&gt;This Makefile also generates the binding definitions (described below) and is used for Cocoa Touch Frameworks.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;XBUILD=/Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild
PROJECT_ROOT=PathToProject
PROJECT=$(PROJECT_ROOT)/NameOfXcodeProject.xcodeproj
TARGET=NameOfTheProject
BINDING_PROJECT=NamespaceOfTheBindings

all: $(TARGET).framework

$(TARGET)-simulator.framework:
	$(XBUILD) ONLY_ACTIVE_ARCH=NO -project $(PROJECT) -target $(TARGET) -sdk iphonesimulator -configuration Release clean build
	mv $(PROJECT_ROOT)/build/Release-iphonesimulator/$(TARGET).framework $(TARGET)-simulator.framework

$(TARGET)-iphone.framework:
	$(XBUILD) ONLY_ACTIVE_ARCH=NO -project $(PROJECT) -target $(TARGET) -sdk iphoneos -configuration Release clean build
	mv $(PROJECT_ROOT)/build/Release-iphoneos/$(TARGET).framework $(TARGET)-iphone.framework

$(TARGET).framework: $(TARGET)-simulator.framework $(TARGET)-iphone.framework $(BINDING_PROJECT)/Generated_ApiDefinitions.cs
	cp -R $(TARGET)-iphone.framework ./$(TARGET).framework
	rm ./$(TARGET).framework/$(TARGET)
	lipo -create -output $(TARGET).framework/$(TARGET) $(TARGET)-iphone.framework/$(TARGET) $(TARGET)-simulator.framework/$(TARGET)

$(BINDING_PROJECT)/Generated_ApiDefinitions.cs:
	 sharpie bind -p Generated_ -n $(BINDING_PROJECT) -o $(BINDING_PROJECT) $(PROJECT)

clean:
	rm -rf *.framework
	rm $(BINDING_PROJECT)/Generated_ApiDefinitions.cs
	rm $(BINDING_PROJECT)/Generated_StructsAndEnums.cs
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;generating-the-bindings-from-the-binary-file&#34;&gt;Generating the bindings from the binary file&lt;/h2&gt;

&lt;p&gt;Generating the API definitions from a binary is as simply as running a single command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sharpie bind -o OutputDirectory -sdk iphoneos9.3 -n MyNamespace MyBinaryFile.a
sharpie bind -o OutputDirectory -sdk iphoneos9.3 -n MyNamespace MyBinaryFile
sharpie bind -o OutputDirectory -sdk iphoneos9.3 -n MyNamespace MyXcodeProject.xcodeproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There will probably be a few warnings in the output, but if you got some errors, you need to choose a different approach or take a look at the Objective-C source code.&lt;/p&gt;

&lt;h2 id=&#34;fixing-the-generated-definitions&#34;&gt;Fixing the generated definitions&lt;/h2&gt;

&lt;p&gt;I haven&amp;rsquo;t done a binding project where the definitions Objective Sharpie generated were perfect. Most of the binding definition syntax is documented on &lt;a href=&#34;https://developer.xamarin.com/guides/cross-platform/macios/binding/binding-types-reference/&#34;&gt;Xamarin&amp;rsquo;s website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s make sure you get the point of these files. The &lt;em&gt;StructsAndEnums.cs&lt;/em&gt; file is just a collection of enums used in the project. The &lt;em&gt;ApiDefinitions.cs&lt;/em&gt; file is the keystone. This file contains a list of interfaces which are used by the Xamarin tooling to create implementations that call the native binary/framework. All we have to do is define the C# interface which is going to be available in our binding and which native method should be used for each C# method/property. A binding project generates a DLL just like any other .NET library.&lt;/p&gt;

&lt;h3 id=&#34;fixing-the-enums&#34;&gt;Fixing the enums&lt;/h3&gt;

&lt;p&gt;You may find the enumerations to be decorated with the &lt;code&gt;[Native]&lt;/code&gt; attribute. This means that it refers to an enum used in the native code. Just make sure that the underlying type of this enum is &lt;code&gt;long&lt;/code&gt;. You&amp;rsquo;ll also notice that Objective Sharpie generates enums where the underlying type is &lt;code&gt;uint&lt;/code&gt; which is technically impossible. I usually make the underlying type &lt;code&gt;byte&lt;/code&gt; unless it has some values defined which don&amp;rsquo;t fit in a byte (0-255).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Native]
public enum ExampleEnum: long
{
    Value1,
    Value2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enums-or-interfaces-decorated-with-the-verify-inferredfrommemberprefix-attribute&#34;&gt;Enums or interfaces decorated with the &lt;code&gt;[Verify(InferredFromMemberPrefix)]&lt;/code&gt; attribute&lt;/h3&gt;

&lt;p&gt;Remove the attribute and verify the name of the interfaces or enum. The name could not be determined by Objective Sharpie and you&amp;rsquo;re probably better of naming it yourself.&lt;/p&gt;

&lt;h3 id=&#34;interfaces-decorated-with-category&#34;&gt;Interfaces decorated with &lt;code&gt;[Category]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;This is a list of extension methods. Make sure the class only contains methods (no properties) as they will all be made static. You can easily replace a property by a method by writing the method yourself and decorating it with the &lt;code&gt;[Export(&amp;quot;nameOfNativeMethod:&amp;quot;)]&lt;/code&gt; attribute.&lt;/p&gt;

&lt;h3 id=&#34;the-partial-constants-interface&#34;&gt;The partial constants interface&lt;/h3&gt;

&lt;p&gt;Usually you&amp;rsquo;ll find a couple of these in the definitions and they&amp;rsquo;re all marked by the &lt;code&gt;[ConstantsInterfaceAssociation]&lt;/code&gt; attribute. Remove the attribute and put all the constants in a single interface decorated with &lt;code&gt;[Static]&lt;/code&gt;. The constants themselves have the &lt;code&gt;[Field]&lt;/code&gt; attribute.&lt;/p&gt;

&lt;h3 id=&#34;interfaces-with-protocol-model&#34;&gt;Interfaces with &lt;code&gt;[Protocol, Model]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;This generates an implementation and an interface. However, you have to declare the interface yourself. So if the native protocol would be called &lt;code&gt;AmazingService&lt;/code&gt;, you&amp;rsquo;d have to add an interface called &lt;code&gt;IAmazingService&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;before&#34;&gt;Before&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;[Protocol, Model]
[BaseType(typeof(NSObject))]
interface AmazingService
{
    a few methods...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;after&#34;&gt;After&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public interface IAmazingService {}

[Protocol, Model]
[BaseType(typeof(NSObject))]
interface AmazingService: IAmazingService
{
    some methods...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;interfaces-decorated-with-verify-methodtoproperty&#34;&gt;Interfaces decorated with &lt;code&gt;[Verify(MethodToProperty)]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s up to you to decide if the bindings should contain properties or methods. Often, you can replace a method with a getter and or you can combine two methods and replace them with a getter and setter. Objective Sharpie also tries to do this for you and marks them with the aforementioned attribute. You can safely remove the attribute and ignore it unless they&amp;rsquo;re part of an interface which is marked with the &lt;code&gt;[Category]&lt;/code&gt; attribute.&lt;/p&gt;

&lt;h3 id=&#34;methods-marked-with-verify-stronglytypednsarray&#34;&gt;Methods marked with &lt;code&gt;[Verify(StronglyTypedNSArray)]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Objective Sharpie couldn&amp;rsquo;t determine the type of the array passed in/out this method/property and used &lt;code&gt;NSObject&lt;/code&gt; as the type. Replace it with a more specific type or let it be and remove the attribute.&lt;/p&gt;

&lt;h3 id=&#34;other-verify-attributes&#34;&gt;Other &lt;code&gt;[Verify]&lt;/code&gt; attributes&lt;/h3&gt;

&lt;p&gt;Run the command &lt;code&gt;sharpie verify-docs&lt;/code&gt; for the latest docs on the &lt;code&gt;[Verify]&lt;/code&gt; attributes you&amp;rsquo;ll find. You have to remove all these attributes before you can compile your binding project.&lt;/p&gt;

&lt;h2 id=&#34;congrats&#34;&gt;Congrats&lt;/h2&gt;

&lt;p&gt;You&amp;rsquo;re no longer a dummy and I hope you have a working binding project. If you&amp;rsquo;re having trouble generating the required binary file, I suggest you contact an iOS developer. If you have some issues with your binding project, send me &lt;a href=&#34;https://twitter.com/SamuelDebruyn&#34;&gt;a tweet&lt;/a&gt; and I&amp;rsquo;ll get in touch ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fix common binding errors with MVVM Light on Xamarin</title>
      <link>https://chipsncookies.com/2016/fix-common-binding-errors-with-mvvm-light-on-xamarin/</link>
      <pubDate>Tue, 22 Mar 2016 20:02:53 +0100</pubDate>
      <author>s@muel.be (Samuel Debruyn)</author>
      <guid>https://chipsncookies.com/2016/fix-common-binding-errors-with-mvvm-light-on-xamarin/</guid>
      <description>

&lt;p&gt;There isn&amp;rsquo;t much documentation available for &lt;a href=&#34;http://www.mvvmlight.net/&#34;&gt;MVVM Light&lt;/a&gt; when it comes to Xamarin.Android and Xamarin.iOS. There are several overloads for the &lt;code&gt;SetBinding&lt;/code&gt; method and using the wrong overload causes &lt;code&gt;TargetInvocationException&lt;/code&gt; or &lt;code&gt;TargetException&lt;/code&gt; like &lt;a href=&#34;http://stackoverflow.com/q/35197870/1592358&#34;&gt;this one&lt;/a&gt;. It&amp;rsquo;s also possible that your bindings don&amp;rsquo;t update anymore after you set one binding using an incorrect syntax.&lt;/p&gt;

&lt;h2 id=&#34;correct-binding&#34;&gt;Correct binding&lt;/h2&gt;

&lt;p&gt;You can only bind on properties, not on fields. You can use the new C# 6 syntax if you like (&lt;code&gt;public TextView TextView =&amp;gt; ...&lt;/code&gt;). They don&amp;rsquo;t always have to be &lt;code&gt;public&lt;/code&gt; but it sure helps making them &lt;code&gt;public&lt;/code&gt; either way. The easiest way to create a new view property on Android is with the &lt;code&gt;mvvmdroidelement&lt;/code&gt; snippet provided by &lt;a href=&#34;https://visualstudiogallery.msdn.microsoft.com/ee36692d-ed3f-4888-b904-281aaaeac529&#34;&gt;this extension&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You should put your bindings in your views and make sure to respect the lifecycle of the platform you&amp;rsquo;re using. Also, always keep a reference to your binding so it doesn&amp;rsquo;t get garbage collected. I usually Store a list with all my bindings in my view.&lt;/p&gt;

&lt;h3 id=&#34;android-activities&#34;&gt;Android activities&lt;/h3&gt;

&lt;p&gt;First create your layout in the &lt;code&gt;OnCreate&lt;/code&gt; method, create and store the bindings and activate/update the view model if necessary. Call &lt;code&gt;Detach()&lt;/code&gt; on every binding in the &lt;code&gt;OnDestroy&lt;/code&gt; method.&lt;/p&gt;

&lt;h3 id=&#34;android-fragments&#34;&gt;Android fragments&lt;/h3&gt;

&lt;p&gt;The layout can be set up in &lt;code&gt;OnCreateView&lt;/code&gt;. Use the &lt;code&gt;OnViewCreated&lt;/code&gt; method to set and store the bindings and activate/update the view model if necessary. Call &lt;code&gt;Detach()&lt;/code&gt; on every binding in the &lt;code&gt;OnDestroy&lt;/code&gt; method.&lt;/p&gt;

&lt;h3 id=&#34;ios-viewcontrollers&#34;&gt;iOS ViewControllers&lt;/h3&gt;

&lt;p&gt;Initialize everything in the &lt;code&gt;ViewDidLoad&lt;/code&gt; method. Then use the &lt;code&gt;ViewWillAppear&lt;/code&gt; method to set and store the bindings. In some rare cases it helps calling &lt;code&gt;ForceUpdateValueFromSourceToTarget&lt;/code&gt; in &lt;code&gt;ViewDidAppear&lt;/code&gt;. Bindings should be detached using &lt;code&gt;Detach()&lt;/code&gt; on the binding in &lt;code&gt;ViewWillDisappear&lt;/code&gt;. You can use &lt;code&gt;DidReceiveMemoryWarning&lt;/code&gt; to clean up or dispose some references.&lt;/p&gt;

&lt;h3 id=&#34;static-view-models&#34;&gt;Static view models&lt;/h3&gt;

&lt;p&gt;To avoid the mentioned &lt;code&gt;TargetException&lt;/code&gt;, I&amp;rsquo;d recommend setting up a static view model locator as &lt;a href=&#34;http://blog.galasoft.ch/posts/2014/10/my-xamarinevolve-talk-is-online-for-your-viewing-pleasure/&#34;&gt;Laurent Bugnion explained&lt;/a&gt; and using the view models on that locator. Injecting a view model in your view to bind on, usually causes the &lt;code&gt;TargetException&lt;/code&gt;, so try to use the view models defined in the locator.&lt;/p&gt;

&lt;h3 id=&#34;is-the-source-of-your-binding-a-property-in-your-view&#34;&gt;Is the source of your binding a property in your view?&lt;/h3&gt;

&lt;p&gt;Then use this one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.SetBinding(() =&amp;gt; Path.To.Property.On.Your.View, App.Locator.MyViewModel, () =&amp;gt; App.Locator.MyViewModel.Path.To.Property.On.Your.ViewModel, BindingMode.OneWay)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;is-the-source-of-your-binding-a-property-in-your-view-model&#34;&gt;Is the source of your binding a property in your view model?&lt;/h3&gt;

&lt;p&gt;Then use the following overload:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;App.Locator.MyViewModel.SetBinding(() =&amp;gt; App.Locator.MyViewModel.Path.To.Property.On.Your.ViewModel, this, () =&amp;gt; Path.To.Property.On.Your.View, BindingMode.OneWay)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;two-way-binding&#34;&gt;Two-way binding&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;this.SetBinding(() =&amp;gt; Path.To.Property.On.Your.View, App.Locator.MyViewModel, () =&amp;gt; App.Locator.MyViewModel.Path.To.Property.On.Your.ViewModel, BindingMode.TwoWay)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;binding-to-a-target-type-different-from-the-source-type&#34;&gt;Binding to a target type different from the source type&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;App.Locator.MyViewModel.SetBinding(() =&amp;gt; App.Locator.MyViewModel.Path.To.Property.On.Your.ViewModel, this, () =&amp;gt; Path.To.Property.On.Your.View, BindingMode.OneWay).ConvertSourceToTarget(ConversionMethod)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use a lambda, but that&amp;rsquo;s harder to debug.&lt;/p&gt;

&lt;h3 id=&#34;just-binding-to-a-source-and-updating-the-view-yourself&#34;&gt;Just binding to a source and updating the view yourself&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;App.Locator.MyViewModel.SetBinding(() =&amp;gt; App.Locator.MyViewModel.Path.To.Property.On.Your.ViewModel).WhenSourceChanges(MyUpdateMethod)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I guess this should cover all cases. I wrote this post using MVVM Light v5.2, but v5.3 or v6 is in the works (probably to be released at Xamarin Evolve 2016), so your mileage may vary with these newer versions.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dependency injection with Autofac and MVVM Light in Xamarin</title>
      <link>https://chipsncookies.com/2016/dependency-injection-with-autofac-and-mvvm-light-in-xamarin/</link>
      <pubDate>Mon, 22 Feb 2016 18:59:37 +0100</pubDate>
      <author>s@muel.be (Samuel Debruyn)</author>
      <guid>https://chipsncookies.com/2016/dependency-injection-with-autofac-and-mvvm-light-in-xamarin/</guid>
      <description>

&lt;h2 id=&#34;you-gotta-have-mvvm&#34;&gt;You gotta have MVVM&lt;/h2&gt;

&lt;p&gt;A developer and his tools are inseparable. We all like &lt;a href=&#34;https://sites.google.com/site/unclebobconsultingllc/getting-a-solid-start&#34;&gt;SOLID&lt;/a&gt; and every (.NET) developer has his or her favourite dependency injection tool. There is &lt;a href=&#34;http://www.hanselman.com/blog/ListOfNETDependencyInjectionContainersIOC.aspx&#34;&gt;a lot&lt;/a&gt; to choose from. I like Autofac because of the way it handles modules, the lifetime of a type and how it registers types.&lt;/p&gt;

&lt;p&gt;At the moment I am working on an app for Android, iOS and Windows Phone with Xamarin and when you’re developing an app in C#, you’ll really want to use MVVM. You can either go the hard way and use the built-in classes, you can go the easy way and use a framework like &lt;a href=&#34;http://caliburnmicro.com/&#34;&gt;Caliburn Micro&lt;/a&gt; or you can go the comfortable way and use &lt;a href=&#34;http://mvvmlight.net&#34;&gt;MVVM Light&lt;/a&gt;. MVVM Light is a toolkit. It comes with everything you need and nothing more. It doesn’t force a pattern upon you, you can use the parts you like and safely ignore everything else. Want to get started with MVVM Light? Make sure to read &lt;a href=&#34;http://www.spikie.be/blog/category/MVVM-Light.aspx&#34;&gt;Nico’s practical guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;MVVM Light comes with an IoC container called SimpleIoC. And that’s what it is: a dead-simple IoC container. As I said: you don’t have to use the parts you don’t like. So let me replace SimpleIoC with my dependency injector of choice: Autofac.&lt;/p&gt;

&lt;h2 id=&#34;architecture&#34;&gt;Architecture&lt;/h2&gt;

&lt;p&gt;This is an overview of how I usually structure my solution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Legend:
* project
  - namespace
    + class/interface


* MyApp (PCL)
  - MyApp.Utilities
    + MyApp.Utilities.ViewModelLocator
    + MyApp.Utilities.CrossPlatformModule
  - MyApp.ViewModels
  - MyApp.Services
    + MyApp.Services.ICrossPlatformService
    + MyApp.Services.IPlatformSpecificService
    + MyApp.Services.MyCrossPlatformServiceImplementation
    + ...
  - ...
* MyApp.Android
  - MyApp.Android.Utilities
    + MyApp.Android.Utilities.PlatformModule
  - MyApp.Android.Services
    + MyApp.Android.Services.MyPlatformSpecificServiceImplementation
    + ...
  - ...
  + App
* MyApp.iOS
  - MyApp.iOS.Utilities
    + MyApp.iOS.Utilities.PlatformModule
  - MyApp.iOS.Services
    + MyApp.iOS.Services.MyPlatformSpecificServiceImplementation
    + ...
  - ...
  + Main
* MyApp.WindowsPhone
  - MyApp.WindowsPhone.Utilities
    + MyApp.WindowsPhone.Utilities.PlatformModule
  - MyApp.WindowsPhone.Services
    + MyApp.WindowsPhone.Services.MyPlatformSpecificServiceImplementation
    + ...
  - ...
  + App
* MyApp.UnitTests
  - ...
    + ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;where-to-put-what&#34;&gt;Where to put what?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Registrations of viewmodels and cross-platform service implementations: MyApp.Utilities.CrossPlatformModule&lt;/li&gt;
&lt;li&gt;Registrations of platform-specific services: MyApp.Platform.Utilities.PlatformModule&lt;/li&gt;
&lt;li&gt;Static properties referring to viewmodels: MyApp.Utilities.ViewModelLocator&lt;/li&gt;
&lt;li&gt;Autofac initialization: MyApp.Utilities.ViewModelLocator&lt;/li&gt;
&lt;li&gt;ViewModelLocator initialization: App/Main&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;how-it-all-ties-together&#34;&gt;How it all ties together&lt;/h2&gt;

&lt;p&gt;First off, you start by creating interfaces for all the services you need. Next up, you can start defining implementations for the services and put them in the correct namespaces.&lt;/p&gt;

&lt;p&gt;When that&amp;rsquo;s done, it&amp;rsquo;s time to create our modules. Now, assembly scanning sometimes causes exceptions on certain platforms. Also, PCL&amp;rsquo;s don&amp;rsquo;t have the methods you&amp;rsquo;re used to from ASP.NET or other types of projects for assembly scanning. I know it makes things incredibly easy, but I&amp;rsquo;d advise against it for Xamarin projects. You&amp;rsquo;ll have to register type by type in the modules. Usually I create an array of types and throw them in &lt;code&gt;builder.RegisterTypes(types)&lt;/code&gt;. The platform-specific modules should contain registrations for the platform-specific services. Don&amp;rsquo;t forget the ones that come with Autofac by default.&lt;/p&gt;

&lt;h3 id=&#34;example-of-a-platform-specific-service&#34;&gt;Example of a platform-specific service&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSharp&#34;&gt;using System;
using Autofac;
using MyApp.Android.Services;
using GalaSoft.MvvmLight.Views;

namespace MyApp.Android.Utilities
{
    public class PlatformModule : Module
    {
        protected override void Load(ContainerBuilder builder)
        {
            var navigationService = new NavigationService();
            // navigationService setup...
            builder.RegisterInstance(navigationService).AsImplementedInterfaces();
            
            Type[] types =
            {
                typeof (DialogService),
                typeof (MyPlatformSpecificServiceImplementation)
            };
            builder.RegisterTypes(types).AsImplementedInterfaces();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think you get my point. The module in your PCL should contain all the cross-platform services and the ViewModels. Don&amp;rsquo;t forget to use &lt;code&gt;.SingleInstance()&lt;/code&gt; where you think it&amp;rsquo;s applicable (e.g. where you use &lt;code&gt;HttpClient&lt;/code&gt; or with some ViewModels).&lt;/p&gt;

&lt;p&gt;When that&amp;rsquo;s done, it&amp;rsquo;s time to use a little bit of magic to make sure the right implementations are registered in the right platform. This can be a little bit tricky and it isn&amp;rsquo;t a very clean solution, but It Does The Job &amp;trade;.&lt;/p&gt;

&lt;p&gt;Laurent, the creator of MVVM Light, gave &lt;a href=&#34;http://blog.galasoft.ch/posts/2014/10/my-xamarinevolve-talk-is-online-for-your-viewing-pleasure/&#34;&gt;a talk at Xamarin Evolve&lt;/a&gt; explaining how he makes it work on Android, iOS and Windows Phone. On Android, you make a singleton class called &lt;code&gt;App&lt;/code&gt; while you use the &lt;code&gt;Application&lt;/code&gt; and &lt;code&gt;App&lt;/code&gt; classes on Windows Phone and iOS.&lt;/p&gt;

&lt;p&gt;But first, we need to create our &lt;code&gt;ViewModelLocator&lt;/code&gt;. Microsoft&amp;rsquo;s ServiceLocator and Autofac&amp;rsquo;s extra&amp;rsquo;s make things easier so all you need is &lt;code&gt;nuget Install-Package Autofac.Extras.CommonServiceLocator&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSharp&#34;&gt;public class ViewModelLocator
{
    // you only need this if you&#39;d like to use design-time data which is only supported on XAML-based platforms
    static ViewModelLocator()
    {
        if (!ServiceLocator.IsLocationProviderSet)
        {
            RegisterServices(registerFakes: true);
        }
    }

    public MyViewModel MyViewModel =&amp;gt; ServiceLocator.Current.GetInstance&amp;lt;MyViewModel&amp;gt;();

    public static void RegisterServices(ContainerBuilder registrations = null, bool registerFakes = false)
    {
        var builder = new ContainerBuilder();

        // you only need this if-clause if you&#39;d like to use design-time data which is only supported on XAML-based platforms
        if (ViewModelBase.IsInDesignModeStatic || registerFakes)
        {
            builder.RegisterModule&amp;lt;FakeServiceModule&amp;gt;();
        }
        else
        {
            // just use this one if you don&#39;t use design-time data
            builder.RegisterModule&amp;lt;CrossPlatformModule&amp;gt;();
        }

        var container = builder.Build();
        registrations?.Update(container);

        ServiceLocator.SetLocatorProvider(() =&amp;gt; new AutofacServiceLocator(container));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now in all of the mentioned app initializers mentioned above I have a method that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSharp&#34;&gt;private static void RegisterServices()
{
    var builder = new ContainerBuilder();
    builder.RegisterModule&amp;lt;PlatformModule&amp;gt;();
    ViewModelLocator.RegisterServices(builder);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That method is then called at the moment I initialize the &lt;code&gt;ViewModelLocator&lt;/code&gt;. Laurent&amp;rsquo;s talk goes in depth on how to do that so I won&amp;rsquo;t cover that part.&lt;/p&gt;

&lt;h2 id=&#34;servicelocator&#34;&gt;ServiceLocator&lt;/h2&gt;

&lt;p&gt;Whenever you need an instance of a registered type, you can use the &lt;code&gt;ServiceLocator&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myService = ServiceLocator.Current.GetInstance&amp;lt;IMyService&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll only need this in the (usually empty) code-behind parts like activities (Android), ViewControllers (iOS) or the page classes (Windows Phone).&lt;/p&gt;

&lt;p&gt;You can even use &lt;a href=&#34;http://docs.autofac.org/en/latest/advanced/delegate-factories.html&#34;&gt;factories&lt;/a&gt; as long as you register them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myVar = &amp;quot;some required constructor parameter for e.g. a ViewModel&amp;quot;;
var factory = ServiceLocator.Current.GetInstance&amp;lt;MyViewModelRequiringAParameter.Factory&amp;gt;();
var vm = factory(myVar);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;questions&#34;&gt;Questions?&lt;/h2&gt;

&lt;p&gt;Questions? Tips/suggestions? &lt;a href=&#34;https://chipsncookies.com/about/&#34;&gt;Let me know!&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>